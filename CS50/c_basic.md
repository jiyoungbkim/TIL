### 1) C 기초

**C언어**

```c
#include <stdio.h>int main(void)
{
    printf("hello, world\n");
}

```

C는 아주 오래되고 전통적인 순수 텍스트 기반의 언어입니다.

하나하나 설명하자면 **int main(void)** 는 스크래치의 “초록색 깃발을 클릭했을 때” 블록과 같은 역할을 합니다.

즉 '**시작한다**'의 의미를 가지고 있다고 보면 됩니다.

앞으로 우리가 작성할 코드 모두는 이 **int main(void) { }**의 중괄호 사이에 작성하게 될 것 입니다.


C에서는 스크래치에서의 say라는 함수는 없습니다. 대신에 **printf**라는 함수가 있습니다.

**printf(“hello, world\n”)** 은 스크래치의 “‘hello, world’라고 말하기” 블록과 같은 역할을 합니다.

글자나 단어, 문장을 적을 때는 **언제나 텍스트에 " " 쌍따옴표로 감싸야 합니다**.

그리고 우리가 일상에서 문장의 끝에 마침표(.)를 붙이는 것 처럼 C에서는 **세미콜론(;)**을 붙여야 합니다.

(아래 사진파일에는 나와있지 않지만 **\n**은 줄바꿈의 기능을 합니다. 키보드에서 ENTER의 기능과 동일합니다.)



**#include <stdio.h>**는 “stdio.h”라는 이름의 파일을 찾아서 “printf” 함수에 접근할 수 있도록 해줍니다.

제일 중요한 것은 중간에 있는 **printf("hello, world")**입니다.

우리가 Word로 문서를 저장했을때 "문서.docx"와 같이 .docx가 붙는 것 처럼, C로 작성한 코드는 **“파일이름.c”**로 저장해야 합니다. (확장자 “.c”는 C로 작성된 코드라는 의미입니다.)

마이크로소프트의 Word 처럼 자동적으로 붙여주지 않기 때문에 C의 경우에는 직접 .c를 붙여줘야 합니다.

**컴파일러**

우리가 직접 작성한 코드는 **“소스 코드”** 라고 불립니다. 이를 2진수로 작성된 “머신 코드”로 변환해야 컴퓨터가 이해할 수 있습니다. 이런 작업을 컴파일러라는 프로그램이 수행해줍니다.

터미널창의 명령어 프롬프트에서 “$” 기호 옆에우리가 원하는 명령어를 입력하면 됩니다.

clang hello.c 라는 명령어는 “clang” 이라는 컴파일러로 “hello.c”라는 코드를 컴파일하라는 의미입니다.

그 결과 **a.out** 이라는 파일이 생성됩니다.

**./a out** 이라는 명령어를 실행하면 컴퓨터가 현재 디렉토리에 있는 a.out이라는 프로그램을 실행하게 해줍니다.(**.**/a out에서 제일 앞에 있는 **.**은 지금 있는 현재 폴더를 나타냅니다.)

```c
$ clang hello.c // 컴파일
$ ./a.out // 실행
hello, world
$ clang -o hello hello.c // hello라는 이름으로 컴파일
$ ./hello // 실행
hello, world
$ ls // 파일 목록 보기 
a.out* hello* hello.c // *붙은 것은 머신코드 없는 것은 소스코드
$ rm a.out // a.out 지우기
rm: remove regular file 'a.out'? y
$ ls // 지워졌는지 확인
hello* hello.c
```

### 2) 문자열

저번 강의에서는 간단하게 Hello World를 출력해보았습니다. 이번 시간에는 좀 더 다이나믹한 것을 해보도록 하죠. 스크래치 강의에서 사용자의 이름을 입력으로 받고 그리고 그 사람의 이름을 불러서 인사를 했습니다.

그럼 이것을 C로 해보면 어떻게 될까요?

CS50 Sandbox에서는 스크래치의 ask함수와 가장 비슷한 것은 **get_string 함수**입니다.

String은 단어나 구절, 문장을 부르는 말입니다. (숫자와는 다른 종류의 데이터 입니다.)

사용자의 이름을 받아서 저장할**변수**를 스크래치와 같이 **answer**이라고 정해보겠습니다. 이때 변수는 xyz, name 등과 같이 **여러분 마음대로 정하셔도 무관합니다**.

하지만 여기서 유의해할 점은 C는 오래된 언어이기 때문에 변수가 저장하는 **데이터의 종류를 아주 정확하게 명시해줘야 합니다**.

그래서 우리는 저장하고자 하는 값의 종류가 **문자열(string)**이라는 것을 알려줘야 합니다. 이때 string을 **형식지정자**라고 합니다.

왜냐하면 너무나 당연하게 이름은 숫자가 아닌 문자이기 때문에 컴퓨터에게 "answer에 들어갈 것들은 문자야!"라고 말해주는 것이죠


우리가 일반적으로 사용하는 **=**은 같다 입니다. 하지만 프로그래밍 언어에서는 오른쪽에서 왼쪽으로 가는 화살표와 비슷하다고 생각해주시면 좋습니다. 쉽게 말하자면 오른쪽에 있는 것을 왼쪽에 **지정**한다는 것이죠. 이를 할당 연산자라고 합니다.

**get_string 함수가 사용자의 이름을 반환하면 그 이름을 anwser이라는 변수에 저장**하는 것입니다.


그럼 이 것을 printf 함수로 출력을 해보도록 하겠습니다.

이때 유의할 점은 printf("hello, answer");이 아니라는 점입니다.

이 코드를 실행한다면 answer이 출력이 되어 hello, answer이 그대로 결과로 나옵니다.

우리는 answer이라는 변수에 들어있는 이름을 출력을 해야하기 때문에 **%**를 사용해 줍니다.

이 때도 어떤 종류의 인자를 받는지 말해줘야 합니다.

우리는 이름이라는 문자열을 받기때문에 **string**에서의 **s**를 **%**뒤에 붙여서 인자를 받아줍니다.

그래서 최종적으로는 **printf("hello, %s\n", answer);**이 되는 것입니다.

가장 위에 포함된 cs50.h 파일 안에 string이라는 문자열 형식과 get_string 이라는 함수에 대한 코드가 포함되어 있습니다. 이 파일을 포함해야만 전체 코드를 컴파일 하고 실행할 수 있습니다.

터미널창에 아래 명령어를 입력하여 컴파일을 할 수 있습니다.

```
$ clang -o string string.c -lcs50
```

여기서 -o string 은 string.c 를 string.out 이라는 머신코드로 저장하도록 하는 명령어입니다.

-lcs50은 “link”라는 의미를 지닌 -l 이라는 인자에 우리가 추가로 포함한 “cs50” 파일을 합친 것입니다. 이를 통해 컴파일시 cs50 파일을 연결하도록 알려줄 수 있습니다.

다소 복잡한 이런 과정 대신에, 아래 make 명령어를 통해 간단하게 컴파일을 수행할 수도 있습니다.

```
$make string //make 프로그램명
```

이와 같이 작성한 코드를 컴파일 하고 실행하면, 사용자에게 입력값을 받고 문장 내에 포함하여 출력하는 프로그램이 됩니다.
